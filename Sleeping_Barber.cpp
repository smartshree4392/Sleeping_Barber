
 
#include <iostream>
#include <thread>
#include <deque>
#include <cstdlib>
  
using namespace std;

 
 
int cust_id = 0;

deque < int >waiting_room;			/*declare a deque to manage the waiting customers*/

thread tarr[1000];				/*create an array of threads to generate and execute threads in parallel*/

int i = 1;

int capacity;				        /*capacity of waiting room; to be taken as an input from command line*/

int haircut_interval;		/*the time barber takes to complete hair cuts of customers; it will be autogenerated randomly from 1 to 5*/

 
int
print_waiting_room () 
{
  
cout << "Waiting room: ";
  
for (int k = 0; k < waiting_room.size (); k++)
    
    {
      
cout << waiting_room[k] << " ";			/*printing customer ids of customers in the waiting room*/
    
} 
cout << endl;
  
 
return 0;

}


 
int
serve_the_customer (int c_id) 
{
  
cout << "Barber is cutting hair of customer " << c_id << endl;
  
return 0;

}


 
int
call_barber_cutting_hair () 
{
  
while (true)
    
    {
      
if (waiting_room.size () > 0)
	
	{
	  
print_waiting_room ();

thread t5 (serve_the_customer, waiting_room[0]);	/*generating a thread to serve the customer*/
	  
haircut_interval = (rand () % 5) + 1;			/*generating a random value for a haircut interval*/

this_thread::sleep_for (chrono::milliseconds (haircut_interval)); /*making a thread sleep for the above generated interval*/
	  

	  
t5.join ();					/*joining this thread to the main thread*/
	  
waiting_room.pop_front ();			/*removing the customer from list after being served*/
	
}
      
      else
	
	{

	  
this_thread::sleep_for (chrono::milliseconds (2000));		/*if there are no customers waiting then barber will sleep*/

cout << "Barber is sleeping" << endl;

	
}
    
}

}


 
int
add_customer_to_waiting_room1 (int customer_id) 
{
  
waiting_room.push_back (customer_id);			/*adding a new customer to the deque*/
  
return 0;

}


 
int
add_customer_to_waiting_room () 
{
  
while (i > 0)							/*for the infinite loop*/
    
    {
      
i = i + 1;
      
cust_id = cust_id + 1;
      
if (waiting_room.size () < capacity)				/*to restrict the customers in the waiting room below the entered capacity*/
	
	{
	  
tarr[i] = std::thread (add_customer_to_waiting_room1, cust_id);      /*creating a thread for adding customer to waiting room*/
	  
this_thread::sleep_for (chrono::milliseconds (3000));			/*waiting for 3 secs before adding another customer*/
	  
tarr[i].join ();							/*joining this thread to the main thread*/
	  
print_waiting_room ();						/*printing waiting room elements*/
	
}
      
      else
	
	{
	  
cout << "Customer " << cust_id << " leaving." << endl;
	  
print_waiting_room ();
	
 
}
      
this_thread::sleep_for (chrono::milliseconds (1000));
    
}
  
return 0;

}


 
 
 
int
main () 
{
  
 
cout << "Enter the capacity of waiting room." << endl;
  
cin >> capacity;
  
thread t1 = std::thread (add_customer_to_waiting_room);		/*creating first thread for adding customers to waiting room*/	
  
thread t2 = std::thread (call_barber_cutting_hair);		/*creating thread which will call barber to serve customers*/
  
t1.join ();							/*joining to main thread*/
  
t2.join ();							/*joining to main thread*/
  
 
 
return 0;

 
}


